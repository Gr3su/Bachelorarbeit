\section{Kompressions Algorithmen}\label{sec:kompressionsAlgorithmen}
Alle Funktionen in diesem Kapitel haben an ihrem Anfang den Aufruf der Funktion \lstinline|checkParameters|, um die Datentypen der übergebenen Argumente zu validieren. In diesem Teil des Codes kommen zwei Open Source Bibliotheken zum Einsatz, und zwar \lstinline|Numpy| \cite{cksr2020} und \lstinline|PyWavelets| \cite{grfk2019}.

Die Funktion \lstinline|polynomialApproximation| in \textit{CompressionAlgorithms.py}, auch zu sehen in \autoref{lst:stückweisepolynomielleapproximation}, ist dazu da, jede Variable einer \ac{MZR} stückweise polynomielle zu approximieren und dadurch zu komprimieren. Die Funktion \lstinline|linearApproximation| ist identisch zu dieser, außer dass der Parameter \lstinline|deg| in Zeile 9 auf 1 statt 3 gesetzt wird. Daher wird diese Funktion in \autoref{sec:kompressionsAlgorithmen} nicht weiter beschrieben.

In Zeile 4 wird die \lstinline|list| Variable \lstinline|compressedMultivariateTimeSeries| initialisiert, in der die neuen \lstinline|list| Objekte gespeichert werden, die die komprimierte Werte enthalten. Die erste \lstinline|for|"=Schleife iteriert über die Variablen bzw. die einzelnen Zeitreihen der \ac{MZR}, dabei werden in \lstinline|coefficients| die Koeffizienten der aktuellen Zeitreihe gespeichert. In der zweiten \lstinline|for|"=Schleife werden die einzelnen Segmente approximiert. Dafür iteriert die Schleife über die Indexe der Zeitreihe, die die linken Ränder der Segmente sind und berechnet in Zeile 8 dann den rechten Rand, indem auf den Wert des linken Randes die Segmentlänge \lstinline|segmentLength| addiert wird. Liegt der berechnete rechte Rand oberhalb der Länge der Zeitreihe, so wird er auf den letzten möglichen Wert \lstinline|len(i)| gesetzt. Um der Konvention in Python gerecht zu werden, ist der linke Rand des Segments inklusiv und der rechte Rand exklusiv. Somit kann in Zeile 9 mit \lstinline|i[j:rightBoundary]| direkt das Segment aus der ursprünglichen Zeitreihe herausgeschnitten werden. Die Funktion \lstinline|fit| aus \lstinline|numpy.polynomial.polynomial.Polynomial| findet mit dem Übergabeparameter \lstinline|deg=3| das Polynom 3. Grades, das den least squares fit zu dem Segment \lstinline|i[j:rightBoundary]| hat. Um interne umskalierungen von \lstinline|numpy| rückgängig zu machen und um dann die Koeffizienten des Polynoms zu erhalten, wird in Zeile 10 \lstinline|p.convert().coef| aufgerufen. Diese Koeffizienten werden dann der Liste mit den anderen Koeffizienten angehangen, um nach Beendigung der zweiten Schleife als Liste zu \lstinline|compressedMultivariateTimeSeries| hinzugefügt zu werden.
\begin{lstlisting}[caption=Stückweise polynomielle Approximation, label=lst:stückweisepolynomielleapproximation, style=Python, language=Python]
def polynomialApproximation(multivariateTimeSeries : mts, segmentLength : int):
    checkParameters(multivariateTimeSeries, segmentLength)

    compressedMultivariateTimeSeries = []
    for i in multivariateTimeSeries.multivariateTimeSeries:
        coefficients = np.array([])
        for j in range(0, multivariateTimeSeries.timeSeriesLength, segmentLength):
            rightBoundary = j + segmentLength if j + segmentLength <= len(i) else len(i)
            p = Pol.fit(range(0, segmentLength), i[j:rightBoundary], deg=3)
            coefficients = np.append(coefficients, p.convert().coef)
        
        compressedMultivariateTimeSeries.append(coefficients.astype(float).tolist())
    return compressedMultivariateTimeSeries
\end{lstlisting}

Die Funktion \lstinline|dwtApproximation| in \textit{CompressionAlgorithms.py}, auch zu sehen in \autoref{lst:diskretewavelettransformation}, ist dazu da, jede Variable einer \ac{MZR} mit der diskreten Wavelet"=Transformation zu approximieren und dadurch zu komprimieren.

In Zeile 4 wird die \lstinline|list| Variable \lstinline|compressedMultivariateTimeSeries| initialisiert, in der die neuen \lstinline|list| Objekte gespeichert werden, die die komprimierte Werte enthalten. Die erste \lstinline|for|"=Schleife iteriert über die Variablen bzw. die einzelnen Zeitreihen der \ac{MZR}, dabei wird in \lstinline|data| der aktuelle Stand der Kompression gespeichert. In Zeile 8 werden dann mittels der Funktion \lstinline|pywt.dwt| und der Wavelet \lstinline|db1| die Daten approximiert. Die Approximations"= und Differenz"=Koeffizienten sind die Rückgabewerte der Funktion, wobei \lstinline|data| nur mit den Approximations"=Koeffizienten überschrieben wird. 
\begin{lstlisting}[caption=Stückweise polynomielle Approximation, label=lst:diskretewavelettransformation, style=Python, language=Python]
def dwtApproximation(multivariateTimeSeries : mts, iterations : int):
    checkParameters(multivariateTimeSeries, iterations)

    compressedMultivariateTimeSeries = []
    for i in multivariateTimeSeries.multivariateTimeSeries:
        data = i
        for j in range(0, iterations):
            coefApprox, coefDiff = pywt.dwt(data, 'db1')
            data = coefApprox
        compressedMultivariateTimeSeries.append(data.astype(float).tolist())
    return compressedMultivariateTimeSeries
\end{lstlisting}