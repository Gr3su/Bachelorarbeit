\section{Nützliche Funktionen}
Die Klasse \lstinline|MultivariateTimeSeries| in \textit{Utilities.py}, auch zu sehen in \autoref{lst:multivariateTimeSeries}, ist dazu da, eine \ac{MZR} abzuspeichern und zu validieren.

Die Methode \lstinline{__init__} ist der Konstruktor, der eine \ac{MZR} entgegennimmt und diese in den Zeilen 12 bis 15 auf die richtigen Datentypen validiert. In Zeile 17 wird das erste Element aus \lstinline|timeSeries| zur Liste \lstinline|multivariateTimeSeries| hinzugefügt und in Zeile 18 wird die Anzahl der Elemente von \lstinline|timeSeries[0]| in \lstinline|timeSeriesLength| abgespeichert. Mit der darauffolgenden \lstinline|for|-Schleife werden die restlichen Zeitreihen hinzugefügt. In \lstinline|addTimeSeries| werden die Zeitreihen der Liste \lstinline|multivariateTimeSeries| hinzugefügt, wenn sie eine \lstinline|list| oder \lstinline|numpy.ndarray| sind und wenn sie gleich viele Elemente haben, wie es \lstinline|timeSeriesLength| vorschreibt. 
\begin{lstlisting}[caption=Klasse für \ac{MZR}, language=Python, label=lst:multivariateTimeSeries, style=Python]
class MultivariateTimeSeries:
    def addTimeSeries(self, timeSeries):
        if not isinstance(timeSeries, list) and not isinstance(timeSeries, np.ndarray):
            raise TypeError(f"Erwarte eine List, aber ein {type(timeSeries)} erhalten.")
        
        if len(timeSeries) != self.timeSeriesLength:
            raise ValueError(f"Das Segment hat {len(timeSeries)} Element(e), muss aber {self.timeSeriesLength} haben.")
        
        self.multivariateTimeSeries.append(timeSeries)
    
    def __init__(self, timeSeries):
        if not isinstance(timeSeries, list):
            raise TypeError(f"Erwarte eine List, aber ein {type(timeSeries)} erhalten.")
        if not isinstance(timeSeries[0], list) and not isinstance(timeSeries[0], np.ndarray):
            raise TypeError(f"Erwarte eine List, aber ein {type(timeSeries[0])} erhalten.")
        
        self.multivariateTimeSeries = [timeSeries[0]]
        self.timeSeriesLength = len(timeSeries[0])
        for i in range(1,len(timeSeries)):
            self.addTimeSeries(timeSeries[i])
\end{lstlisting}

Die Funktion \lstinline|execCalcRuntime| in \textit{Utilities.py}, auch zu sehen in \autoref{lst:zeitmessung}, ist dazu da, eine übergebene Funktion aufzurufen und dessen Laufzeit zu messen. Die Funktion gibt sowohl das Ergebnis der übergebenen Funktion, als auch das der Zeitmessung zurück.
\begin{lstlisting}[caption=Funktion zur Zeitmessung, language=Python, label=lst:zeitmessung, style=Python]
def execCalcRuntime(func, *args):
    start = perf_counter()
    result = func(*args)
    end = perf_counter()
    return result, end - start
\end{lstlisting}

Das Skript in \textit{DataPreparation.py}, auch zu sehen in \autoref{lst:dataPreparation}, ist dazu da, die Rohdaten für das Experiment vorzubereiten. Die Hauptfunktionalität ist dabei in \autoref{lst:dataPreparation} zu sehen, die Funktionen, die dort aufgerufen werden, befinden sich in derselben Datei, werden allerdings nicht näher beschrieben als in diesem Abschnitt.

Der erste Übergabeparameter des Skriptes ist der Ordner, an dem die originalen Dateien der Rohdaten liegen, typischerweise der Form \textit{DatenName/original}. Mithilfe dieses Pfades, werden die Pfade aller Dateien in \lstinline|full_paths| geladen, wobei in Zeile 3 nochmal geprüft wird, ob auch wirklich jeder Pfad eine Datei und nichts Sonstiges ist. Der Aufruf der Funktion \lstinline|readFiles(full_paths)| liest jede Datei ein, speichert sie in einem String und gibt diese Strings dann in einer Liste zurück. Mit dem zweiten Übergabeparameter kann übergeben werden, welche Daten eingelesen wurden. Dadurch wird die Funktion \lstinline|nvidiaData|, \lstinline|euWeatherData| oder \lstinline|ecg500| aufgerufen, die dann innerhalb von \lstinline|contents| die relevanten Daten herausfiltert und in \lstinline|full_paths| die neuen Dateipfade speichert. \lstinline|writeFiles(full_paths, contents)| schreibt dann die Inhalte in csv"=Dateien, typischerweise an die Stelle \textit{DatenName/original/.\,.\,/prepared/}.
\begin{lstlisting}[caption=Funktion zur Zeitmessung, language=Python, label=lst:dataPreparation, style=Python]
if __name__ == "__main__":
    full_paths = [os.path.join(sys.argv[1], filename) for filename in os.listdir(sys.argv[1])]
    full_paths = [path for path in full_paths if os.path.isfile(path)]

    contents = readFiles(full_paths)
    match int(sys.argv[2]):
        case 0:
            nvidiaData(contents, full_paths)
        case 1:
            euWeatherData(contents, full_paths)
        case 2:
            ecg500(contents, full_paths)
    writeFiles(full_paths, contents)
\end{lstlisting}